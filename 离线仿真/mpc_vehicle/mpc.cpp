#include    "mpc.h"
#include	<string.h>
#include	<math.h>
#include	<time.h>
#include  <iostream>
unsigned long int seed_1 = 9;
double randac()
{
	const unsigned long int a =45;
	const unsigned long m = pow(2.0,20);
	unsigned long  i1;
	
	i1 = (a* seed_1)%m;
	seed_1 = i1;
	
	return (double)(i1)/(double)(m);
}


double fitness(double x[2],double G[2],double b[4])
{
	 double H[2][2]={     231.5891983880240,   210.4915536015400,  210.4915536015399,   225.4663393899590};
//double H[2][2]={     133.4686015035994 ,  113.2469001604079,113.2469001604079  , 129.0905294439496};
	double D=2;
	double r=0.1;
	double c[4][2]={-1,0,0,-1,1,0,0,1};
	double aa[4];
	double Cx[4]={0.0};
	double result;
    int i;
    double sum=0;
    int k;
    double xH[2]={0.0};
    double xHx=0.0;
	double Gx=0.0;
// 	for(i = 0; i < 4;i++)
// 	{
// 		Cx[i] = 0;
// 	}
	for( i=0;i<4;i++)
	{
        int j;
		for( j=0;j<2;j++)
		{
			Cx[i]+=c[i][j]*x[j];
		}
		aa[i]=Cx[i]-b[i];
	}

	for ( k=0;k<4;k++)
	{
		double min[4];
    if(aa[k]<=0)
		min[k]=aa[k];
	else
		min[k]=0;
	sum+=min[k]*min[k];
	}
	
// 		for(i = 0; i <2;i++)
// 	{
// 		xH[i] = 0;
// 	}

	for(i=0;i<2;i++)
    {	
        int j;
        for( j=0;j<2;j++)
		{
		xH[i]+=0.5*x[j]*H[j][i];
		}
    }   
   
	for( i=0;i<2;i++)
		{
		xHx+=xH[i]*x[i];
		Gx+=(-1)*G[i]*x[i];
		}
    //result=xHx+Gx+10000000*sum;
    result=xHx+Gx+5000*sum;
	return result;
}

double pso(double G[2],double b[4])
{
    double UU[2];
	//const int c1=2;
	//const int c2=2;
    double c1=1.4962;            //学习因子1
    double c2=1.4962;             //学习因子2
	double w=0.7298;
	const int MaxDT=20;            //最大迭代次数30
	const int D=2;                  //搜索空间维数（未知数个数）
	const int N=20;                  //%初始化群体个体数目       
	double eps=0.000001;             //%设置精度(在已知最小值时候用)
    double x[20][2];
    double y[20][2];
	double v[20][2];
	double p[20]={0.0};
	double pg[2];
    double randac1=0.0;
    double randac2=0.0;
    int t;
	//%------初始化种群的个体(可以在这里限定位置和速度的范围)------------
	double r=0.1;
    int i;
    int j;
	for ( i=0;i<N;i++)
	{
       	for ( j=0;j<D;j++)
		{
			x[i][j]=0.001*randac();  //%随机初始化位置
			v[i][j]=0;  //%随机初始化速度
		}
	}

	//%------先计算各个粒子的适应度，并初始化Pi和Pg----------------------
	for ( i=0;i<N;i++)
		
	{
        p[i]=fitness(x[i],G,b);
		printf("p[%d]=%lf\n",i,p[i]);
		for(j=0;j<D;j++)
		{
		y[i][j]=x[i][j];
		}
	}
	
		for( j=0;j<D;j++)
	{
		pg[j]=x[0][j];//%Pg为全局最优
	}
           
	for (i=1;i<N;i++)
		
	{
		if (fitness(x[i],G,b)<fitness(pg,G,b))
			for(j=0;j<D;j++)
			{
			pg[j]=x[i][j];
			//printf("pg[%d]=%lf\n",j,pg[j]);
			}
	}
	
	//%------进入主要循环，按照公式依次迭代，直到满足精度要求------------
   	for ( t=0;t<MaxDT;t++)
	{
        int k;
		w=0.8-0.6*(t+1)/MaxDT;
		for(i=0;i<N;i++) 
		{
            randac1=randac();
            randac2=randac();
			//printf("randac1=%lf\n",randac1);
			//printf("randac2=%lf\n",randac2);
			for( j=0;j<D;j++)
		    {
                v[i][j]=w*v[i][j]+1*c1*randac1*(y[i][j]-x[i][j])+1*c2*randac2*(pg[j]-x[i][j]);
                x[i][j]=x[i][j]+v[i][j];
			

			/*if(j==D-1)
				{
					printf("x[%d][%d]=%lf\n",i,j,x[i][j]);
				}
				else
				{
					printf("x[%d][%d]=%lf\n",i,j,x[i][j]);
				}*/
		
             }

			for ( k=0;k<D;k++)
			{
			if  (x[i][k]>1)
				{
					x[i][k]=1;
				}
			if (x[i][k]<-1)
				{
				x[i][k]=-1;
				}
			}
			if (fitness(x[i],G,b)<p[i])
			{
				p[i]=fitness(x[i],G,b);
				for( j=0;j<D;j++)
				{
				y[i][j]=x[i][j];
				}
			}
			if (p[i]<fitness(pg,G,b))
			{
				for( j=0;j<D;j++)
				{
				pg[j]=y[i][j];
				//printf("pg[%d]=%lf\n",j,pg[j]);
				}
			}

	    }
	
	}
	for(i=0;i<D;i++)
	{
	    UU[i]=pg[i];
	}
    return UU[0];
}

double mpc_pso(double belta,double r,double y,double u,double ref)
{
	double duu;
    double Sx[20][2]={ 0.999999887494521,   0.000980908441683,
                       1.999999443182048,   0.002905510919606,
                       2.999998456081107,   0.005738004675732,
                       3.999996723214666,   0.009443945051661,
                       4.999994049306499,   0.013990193972083,
                       5.999990246489080,   0.019344870382393,
                       6.999985134022543,   0.025477302566354,
                       7.999978538024314,   0.032357982272474,
                       8.999970291208991,   0.039958520580513,
                       9.999960232638099,   0.048251605442091,
                      10.999948207479330,   0.057210960831894,
                      11.999934066774919,   0.066811307448406,
                      12.999917667218810,   0.077028324905356,
                      13.999898870942264,   0.087838615357362,
                      14.999877545307610,   0.099219668505353,
                      15.999853562709818,   0.111149827929432,
                      16.999826800385591,   0.123608258698829,
                      17.999797140229713,   0.136574916210506,
                      18.999764468618345,   0.150030516209793,
                      19.999728676239037,   0.163956505948230};
/*double Sx[20][2]={   0.999999889985897 ,  0.000948508928565,
   1.999999464904026,   0.002749553191219,
   2.999998540448825,   0.005316869946928,
   3.999996950963507,   0.008572924559377,
   4.999994547553154,   0.012448027464021,
   5.999991196388720,   0.016879540391852,
   6.999986777182649,   0.021811162908661,
   7.999981181818721,   0.027192291143319,
   8.999974313120543,   0.032977441400918,
   9.999966083744637,   0.039125732095589,
  10.999956415185531,   0.045600418102155,
  11.999945236881521,   0.052368472222782,
  12.999932485410900,   0.059400209001464,
  13.999918103769533,   0.066668946601536,
  14.999902040721505,   0.074150702894921,
  15.999884250215494,   0.081823922301536,
  16.999864690860182,   0.089669230267496,
  17.999843325452748,   0.097669212585581,
  18.999820120555071,   0.105808217044403,
  19.999795046112812,   0.114072175146993};*/

   double g[2][20]={ 0.295173465193610,	1.16571436196475,	2.58979392352947,	4.54641140982271,	7.01536269810910,	9.97721006504063,	13.4132531149660,	17.3055008110112,	21.6366445671002,	26.3900323606712,	31.5496438273702,	37.1000663004737,	43.0264717592035,	49.3145946514563,	55.9507105577808,	62.9216156646895,	70.2146070166061,	77.8174635169120,	85.7184276496769,	93.9061878947356,
                      0,                	0.295173465193610,	1.71925302675833,	3.67587051305157,	6.14482180133796,	9.10666916826949,	12.5427122181949,	16.4349599142401,	20.7661036703291,	25.5194914639001,	30.6791029305990,	36.2295254037026,	42.1559308624323,	48.4440537546851,	55.0801696610096,	62.0510747679183,	69.3440661198349,	76.9469226201408,	84.8478867529057,	93.0356469979644};
    /*  double g[2][20]={  0.288637000935113,   1.115260253385277 ,  2.425434282926009 ,  4.170231478763938,   6.305674799764710  , 8.792236868327832 , 11.594389746700799,  14.680200267606672 , 18.020966309930749 , 21.590889876583358,  25.366783250838921,  29.327804884220999 , 33.455222007650598 , 37.732197261957495,  42.143596917439140 , 46.675818498054518 , 51.316635846863008,  56.055059867976176 , 60.881213358849699 , 65.786218507233201,
                        0 ,  0.288637000935113 ,  1.598811030475845  , 3.343608226313774 ,  5.479051547314546,   7.965613615877669,  10.767766494250637,  13.853577015156507,  17.194343057480580,  20.764266624133192,  24.540159998388752,  28.501181631770827,  32.628598755200436 , 36.905574009507333, 41.316973664988971,  45.849195245604349,  50.490012594412846,  55.228436615526007,  60.054590106399530 , 64.959595254783039};*/

	//double g[2][20];
    int i;
    int j;
    double Umax=0.8;
	double Umin=-0.8;
	double SxDx[20];
	double b[4];
	double G[2];
    double Ep[20];
   // double UU[2]={0.0,0.0};
// 	for( i=0;i<2;i++)
// 		for( j=0;j<20;j++)
// 		{
// 			g[i][j]=g1[j][i];
// 		}
   
	b[0]=u - Umax;
	b[1]=u - Umax;
	b[2]=Umin-u ;
	b[3]=Umin-u ;
	printf("b[0]=%lf\n",b[0]);
	printf("b[2]=%lf\n",b[2]);
	
	for( i=0;i<20;i++)
	{
		SxDx[i]=Sx[i][0]*belta+Sx[i][1]*r;
		//printf("SxDx[%d]=%lf\n",i,SxDx[i]);
	}
	for( i=0;i<20;i++)
	{
		Ep[i]=ref-SxDx[i]-y;
		printf("Ep[%d]=%lf\n", i, Ep[i]);
	}
	for(i=0;i<2;i++)
	{
		double sum=0.0;
		for(j=0;j<20;j++)
		sum+=g[i][j]*Ep[j];
		//G[i]=10000000000*sum;
		G[i]=sum;
		printf("G[%d]=%lf\n",i,G[i]);
	}

	duu=pso(G,b);
	return duu;
    
}

double input_dx1(double y)
{
	static double x1=0;
	static double x1_1=0;
	double dx1;

	x1=y;
	dx1=x1-x1_1;
	x1_1=x1;

	printf("dx1=%lf\n",dx1);
	return dx1;
}

double input_dx2(double dx1)
{
	static double x2=0;
	static double x2_2=0;
	double dx2;
	int ts=500;

	x2=dx1*ts;
	printf("x2=%lf\n",x2);
	dx2=x2-x2_2;
	x2_2=x2;
	//printf("x2_2=%lf\n",x2_2);

	printf("dx2=%lf\n",dx2);
	return dx2;
}

double Compult(double y_in,double ref_in)
{
	double y;
	double ref;
	double dx1;
	double dx2;
	double du;
	//double u_out;
    static double u=0;
	y=y_in;
	ref=ref_in;
	//ap_fixed<26,16,AP_RND_CONV,AP_SAT> my_factor_u= 30000;

	dx1=input_dx1(y);
	dx2=input_dx2(dx1);
	//printf("dx2=%lf\n",dx2);
	du=mpc_pso(dx1,dx2,y,u,ref);
	u=u+du;
	//u_out=u*my_factor_u;
	return du;
}